<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Word Cluster Force Directed Graph</title>
    <style>
        body {position:relative;margin:0 auto;font-family:"Courier","sans-serif";background-color:powder}
        div{border:0px solid;}
        input.slider{margin:5px auto;width: 300px;font-size: 1em;}
    </style>

    <!--D3-->
<script src="{{ url_for('static', filename='js/third-party/d3/d3.min.js') }}"></script>

    <!--JS for this vis -->
    <script>
var graph;
var data;
var sizeScale;
var colorScale;

var limit = 1;
var reserved = ["group"];

var words = [];
var linked = [];

function make_graph(el) {

    this.addNode = function (id, r, c) {
        nodes.push({"id": id, "r": r, "color": c});
        update();
    };

    this.removeNode = function (id) {
        var i = 0;
        var n = findNode(id);
        while (i < links.length) {
            if ((links[i]["source"] == n) || (links[i]["target"] == n)) {
                links.splice(i, 1);
            }
            else i++;
        }
        nodes.splice(findNodeIndex(id), 1);
        update();
    };

    this.removeAllNodes = function () {
        nodes.splice(0, links.length);
        update();
    };

    this.addLink = function (source, target, value) {
        links.push({"source": findNode(source), "target": findNode(target), "value": value});
        update();
    };

    this.removeLink = function (source, target) {
        for (var i = 0; i < links.length; i++) {
            if (links[i].source.id == source && links[i].target.id == target) {
                links.splice(i, 1);
                break;
            }
        }
        update();
    };

    this.removeallLinks = function () {
        links.splice(0, links.length);
        update();
    };

    var findNode = function (id) {
        for (var i in nodes) {
            if (nodes[i]["id"] === id) return nodes[i];
        }
    };

    var findNodeIndex = function (id) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].id == id) {
                return i;
            }
        }
    };

    // set up the plot in the specified element.
    var w = 800,
        h = 700;

    var vis = d3.select(el)
        .append("svg:svg")
        .attr("width", w)
        .attr("height", h)
        .attr("id", "svg")
        .attr("pointer-events", "all")
        .attr("perserveAspectRatio", "xMinYMid")
        .append("svg:g");

    var force = d3.layout.force(),
        nodes = force.nodes(),
        links = force.links();

    var update = function () {
        var link = vis.selectAll("line")
            .data(links, function (d) {
                return d.source.id + "-" + d.target.id;
            });

        link.enter().append("line")
            .attr("id", function (d) { return d.source.id + "-" + d.target.id; })
            .attr("opacity", 1)
            .attr("stroke-width", 1)
            .attr("stroke", "blue")
            .attr("opacity", 0.3)
            .attr("stroke-width", function (d) {
                return (Math.abs(d.value) + 1) * 1.5
            })
            .attr("stroke", function (d) {
                if (d.value > 0) {
                    return "teal"
                } else {
                    return "pink"
                }
            })
            .attr("class", "link");

        link.append("title")
            .text(function (d) {
                return d.value;
            });

        link.exit().transition().remove();


        var node = vis.selectAll("g.node")
            .data(nodes, function (d) {
                return d.id;
            }); //.on('mouseover', showAaInfo);

        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .call(force.drag);

        nodeEnter.append("svg:circle")
            .attr("r", function (d) {
                return d.r * 3
            })
            .attr("id", function (d) {
                return "Node_" + d.id;
            })
            .attr("fill", function (d) {
                return d.color
            })
            .attr("class", "nodeStrokeClass");

        nodeEnter.append("svg:text")
            .attr("text-anchor", "middle")
            .attr("class", "textClass")
            .attr("id", function (d) {
                return "Node_" + d.id;
            })
            .attr("fill", "black")
            .attr("font-size", function (d) {
                return d.r * 6
            })
            .attr("text-align", "center")
            //.attr("dx", function(d){return -d.r*1.2})
            .attr("dy", function (d) {
                return d.r * 1.9
            })
            .text(function (d) {
                return d.id;
            });

        node.exit().remove();
        force.friction(0.9);
        force.on("tick", function () {
            node.attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

            link.attr("x1", function (d) {
                    return d.source.x;
                })
                .attr("y1", function (d) {
                    return d.source.y;
                })
                .attr("x2", function (d) {
                    return d.target.x;
                })
                .attr("y2", function (d) {
                    return d.target.y;
                });


        });

        // Restart the force layout.
        force
            .gravity(.2)
            .friction(0.7)
            .charge(-500)
            .distance(100)
            .linkDistance(100)
            .size([w, h])
            .start();
    };


    // Make it all go
    update();

}

function initialize() {
    // Build graph.
    graph = new make_graph("#graph");
    data = [];
	d3.csv("{{ url_for('static', filename='coge_embed.csv') }}", function(curr){
         //   // Save data from CSV.
        data = curr;
        console.log(data);
//    var data = {{reader}};


        // Set up scales.
        // For each word, get it's count and group number.
        // Create size scale by min-max of counts, and color scale by number of groups.
        var sizes = [];
        var groups = [];
        for (var h=0; h<data.length; h++) {
            var w = data[h][""];
            if (reserved.indexOf(w) > -1) { continue; }

            sizes.push(parseInt(data[h][w]));
            var g = parseInt(data[h]["group"]);
            if (groups.indexOf(g) < 0) { groups.push(g); }
        }
        sizeScale = d3.scale.linear().range([1,8]).domain([Math.min.apply(null, sizes), Math.max.apply(null, sizes)]);
        if (Math.max.apply(null, groups) <= 10) { colorScale = d3.scale.category10(); } // <10 groups use cat10.
        else { colorScale = d3.scale.category20(); } // >10 groups use cat20.

        // Add Nodes.
        // For each word, create a node with radius = scaled count, color = group #.
        for (var i=0; i<data.length; i++) {
            var word = data[i][""];
            words[i] = word;
            if (reserved.indexOf(word) > -1) { continue; } // Skip reserved words.

            var radius = sizeScale(parseInt(data[i][word]));
            var color = colorScale(parseInt(data[i]["group"]));
            graph.addNode(word, radius, color);
        }

        // Add Edges.
        // Connect nodes by group #.
        var x = words.length;
        for (var j=0; j<x; j++) {
            for (var k=j; k<x; k++) {
                var word_a = words[j];
                if (reserved.indexOf(word_a) > -1) { continue; } // Skip reserved words.
                var word_b = words[k];
                if (reserved.indexOf(word_b) > -1) { continue; } // Skip reserved words.

                var similarity = data[k][word_a];
                if (similarity >= limit) {
                    graph.addLink(word_a, word_b, similarity);
                    linked.push(word_a + "||" + word_b); // Take note that values are currently linked.
                }
            }
        }
    });

    // Set up slider.
    var sliderText = [
        {"label":"SIMILARITY SCORE", "x":75, "y":-3, "fs":"1em", "fc":"gainsboro"},
        {"label":"0", "x":0, "y":20, "fs":"0.9em", "fc":"black"},
        {"label":".5", "x":140, "y":20, "fs":"0.9em", "fc":"black"},
        {"label":"1", "x":285, "y":20, "fs":"0.9em", "fc":"black"}
    ];
    var sl = d3.select("#sliderInfo").append("svg")
                        .attr("height", 35)
                        .attr("width", 300)
                        .attr("color", "ligthgray");

    sl.selectAll("text").data(sliderText).enter().append("svg:text")
                        .attr("class", "sliderText")
                        .text(function(d){return d.label})
                        .attr("x", function(d){return d.x} )
                        .attr("y", function(d){return d.y+15})
                        .attr("font-size", function(d){return d.fs})
                        .attr("fill", function(d){return d.fc});
}

function updateLinks(new_limit) {
    var x = words.length;
    for (var i=0; i<x; i++) {
        for (var j=i; j<x; j++) {
            var word_a = words[i];
            if (reserved.indexOf(word_a) > -1) { continue; } // Skip reserved words.
            var word_b = words[j];
            if (reserved.indexOf(word_b) > -1) { continue; } // Skip reserved words.

            var similarity = data[j][word_a];
            var current_link = linked.indexOf(word_a + "||" + word_b);

            if (similarity >= new_limit) {
                if (current_link < 0) {
                    graph.addLink(word_a, word_b, similarity);
                    linked.push(word_a + "||" + word_b);
                }
            } else {
                if (current_link < 0) {
                    graph.removeLink(word_a, word_b);
                    linked.splice(current_link, 1);
                }
            }
        }
    }
}

function changeLimit(){
	limit = d3.select("#limit").property("value") * 0.01;
	updateLinks(parseFloat(limit));
}



    </script>
    


</head>



<body onload="initialize()" style="padding:20px; min-width:1010px;width:1010px">
    <div id="sliderInfo"></div>
    <input class="slider" type="range" name="limit" id="limit" min="0" max="100" value="100" step="1" onchange="changeLimit()">
    <div id="graph" class="graph"></div>
</body>
</html>